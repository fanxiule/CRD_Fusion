import cv2
import numpy as np
from scipy.ndimage import uniform_filter, sobel, median_filter


class DataPreprocessor:
    """
    Superclass to preprocess a given dataset
    """

    def __init__(self, dataset_path, max_disp, block_sz, match_method):
        """
        Base class to preprocess datasets to generate raw disparity and confidence maps

        :param dataset_path: directory to the dataset
        :param max_disp: maximum disparity to check when matching
        :param block_sz: block size for the stereo algorithm
        :param match_method: choose between local_BM and SG_BM for local or semi-global block matching
        """
        self.dataset_path = dataset_path
        self.max_disp = max_disp
        self.match_method = match_method

        if self.match_method == "localBM":
            self.stereo = cv2.StereoBM_create(numDisparities=self.max_disp, blockSize=block_sz)
        elif self.match_method == "SGBM":
            pre_filter_cap = 15
            p1 = block_sz * block_sz * 4
            p2 = block_sz * block_sz * 64
            uniqueness_ratio = 10
            speckle_window_size = 100
            speckle_range = 2
            disp_max_diff = 1
            full_dp = 1
            self.stereo = cv2.StereoSGBM_create(numDisparities=self.max_disp, blockSize=block_sz, P1=p1, P2=p2,
                                                disp12MaxDiff=disp_max_diff, preFilterCap=pre_filter_cap,
                                                uniquenessRatio=uniqueness_ratio, speckleWindowSize=speckle_window_size,
                                                speckleRange=speckle_range, mode=full_dp)
        else:
            print("Only local block matching or semi-global block matching is allowed to preprocess the data")
            raise RuntimeError

    def _cal_disp(self, l_im, r_im):
        """
        Calculate the disparity and a validity mask for given left and right input images using stereo matching

        :param l_im: left image in the default OpenCV BGR format
        :param r_im: right image in the default OpenCV BGR format
        :return: disparity map & a binary validity mask to indicate if a pixel has been matched or not
        """
        if self.match_method == "localBM":  # local_BM and needs grayscale images
            l_im = cv2.cvtColor(l_im, cv2.COLOR_BGR2GRAY)
            r_im = cv2.cvtColor(r_im, cv2.COLOR_BGR2GRAY)
        disp = self.stereo.compute(l_im, r_im)
        disp = disp / 16.0

        # eliminate negative disparity and disparity very close to 0
        mask = np.copy(disp)
        mask[mask >= 0.001] = 1
        mask[mask < 0.001] = 0
        return disp, mask

    @staticmethod
    def _interpolate_im(r_im, row_ind, corres_col_ind):
        """
        Bilinearly interpolate/sample the right image to build a synthesized left image given the correspondence column
        index and row index

        :param r_im: right image
        :param row_ind: row index or y
        :param corres_col_ind: column index for correspondence points. Generated by the left disparity
        :return: the interpolated/synthetic image
        """
        col_ind_l = np.floor(corres_col_ind).astype(int)
        col_ind_r = np.ceil(corres_col_ind).astype(int)
        weights_l = col_ind_r - corres_col_ind
        weights_r = 1 - weights_l
        weights_l = np.repeat(weights_l[:, :, np.newaxis], 3, axis=2)
        weights_r = np.repeat(weights_r[:, :, np.newaxis], 3, axis=2)
        interpolated_im = weights_l * r_im[row_ind.astype(int), col_ind_l, :] + weights_r * r_im[row_ind.astype(int),
                                                                                            col_ind_r, :]

        return interpolated_im

    @staticmethod
    def _get_img_window(img, size):
        """
        Get corner pixels of an image window centered at each pixel in the image

        :param img: input image
        :param size: window size
        :return: four images with intensity at top left, top right, bottom left, and bottom right corner of each window
        """
        img_tl = np.roll(img, (size, size), axis=(0, 1))
        img_tr = np.roll(img, (size, -size), axis=(0, 1))
        img_bl = np.roll(img, (-size, size), axis=(0, 1))
        img_br = np.roll(img, (-size, -size), axis=(0, 1))
        return img_tl, img_tr, img_bl, img_br

    def _cal_ZSAD(self, l_img, syn_l_img):
        """
        Calculate a simplified version of zero-mean sum of absolute difference (ZSAD)

        :param l_img: left image
        :param syn_l_img: synthetic left image
        :return: simplified ZSAD
        """
        l_img_tl, l_img_tr, l_img_bl, l_img_br = self._get_img_window(l_img, 1)
        syn_l_img_tl, syn_l_img_tr, syn_l_img_bl, syn_l_img_br = self._get_img_window(syn_l_img, 1)

        # *1.0 to change uint8 to float
        l_img_mean = (1.0 * l_img_tl + 1.0 * l_img_tr + 1.0 * l_img_bl + 1.0 * l_img_br + 1.0 * l_img) / 5
        # syn_l_img in float already
        syn_l_img_mean = (syn_l_img_tl + syn_l_img_tr + syn_l_img_bl + syn_l_img_br + syn_l_img) / 5
        ZSAD_tl = np.abs(l_img_tl - l_img_mean - syn_l_img_tl + syn_l_img_mean)
        ZSAD_tr = np.abs(l_img_tr - l_img_mean - syn_l_img_tr + syn_l_img_mean)
        ZSAD_bl = np.abs(l_img_bl - l_img_mean - syn_l_img_bl + syn_l_img_mean)
        ZSAD_br = np.abs(l_img_br - l_img_mean - syn_l_img_br + syn_l_img_mean)
        ZSAD_c = np.abs(l_img - l_img_mean - syn_l_img + syn_l_img_mean)

        ZSAD = ZSAD_tl + ZSAD_tr + ZSAD_bl + ZSAD_br + ZSAD_c
        ZSAD = np.linalg.norm(ZSAD, ord=2, axis=2)
        ZSAD /= np.mean(ZSAD)
        return ZSAD

    @staticmethod
    def _cal_MND(disp, window):
        """
        Calculate mean disparity deviation (MND)

        :param disp: disparity map
        :param window: window size to calculate average
        :return: MND
        """
        mean_disp = uniform_filter(disp, size=window, mode='nearest')
        MND = -np.abs(disp - mean_disp)
        return MND

    @staticmethod
    def _cal_img_grad(img):
        """
        Calculate approximated image gradient with sobel filter

        :param img: input image
        :return: image gradient
        """
        img_x_grad = sobel(img, 1, output=float, mode='nearest')
        img_y_grad = sobel(img, 0, output=float, mode='nearest')
        grad = np.hypot(img_x_grad, img_y_grad)
        grad = np.linalg.norm(grad, ord=2, axis=2)
        return grad

    def _cal_confidence(self, l_im, r_im, disp, mask):
        """
        Calculate the confidence map of the raw disparity

        :param l_im: left RGB image
        :param r_im: right RGB image
        :param disp: predicted raw left disparity
        :param mask: binary mask to indicate if a pixel has been matched successfully
        :return: confidence map
        """
        ZSAD_conf_scaling = 0.24
        MND_conf_scaling = 2
        smooth_scaling = 0.01
        MND_window = 5

        shape = np.shape(l_im)
        height = shape[0]
        width = shape[1]

        # construct synthetic image
        row = np.linspace(0, height - 1, num=height)  # y
        col = np.linspace(0, width - 1, num=width)  # x
        col_ind, row_ind = np.meshgrid(col, row)  # col and row indices of the l_rgb
        shifted_col_ind = col_ind - disp  # corresponding col index on the right image given left disparity
        shifted_col_ind = np.clip(shifted_col_ind, a_min=0, a_max=width - 1)
        syn_l_im = self._interpolate_im(r_im, row_ind, shifted_col_ind)

        # calculate ZSAD based similarity and confidence
        ZSAD = self._cal_ZSAD(l_im, syn_l_im)  # ZSAD positive, higher ZSAD, less similarity
        ZSAD_conf = np.exp(-ZSAD_conf_scaling * ZSAD)
        # calculate MND based difference and confidence
        MND = self._cal_MND(disp, MND_window)  # MND negative, lower the MND, less similarity
        MND_conf = np.exp(MND_conf_scaling * MND)

        # confidence fusion
        l_im_grad = self._cal_img_grad(l_im)
        smooth_weight = np.exp(-smooth_scaling * l_im_grad)
        edge_weight = 1 - smooth_weight
        confidence = smooth_weight * MND_conf + edge_weight * ZSAD_conf
        confidence = median_filter(confidence, size=2, mode='nearest')  # denoise
        confidence *= mask  # remove confidence value for pixels which fail to match

        return confidence

    @staticmethod
    def _disp_encoding(disp):
        """
        Encode the raw disparity with subpixel-level accuracy into a color image. Utilize R and G channels to store
        disparity. Implementation is based on sintel development kit. .png files are more compact than .npy files.

        :param disp: raw disparity
        :return: encoded disparity in the form of BGR image (default OpenCV format)
        """
        disp[disp > 1024] = 1024
        disp[disp < 0] = 0
        encoded_disp = np.zeros((disp.shape[0], disp.shape[1], 3), dtype='uint8')
        d_r, remainder = np.divmod(disp, 4.0)
        d_r = d_r.astype('uint8')
        d_g = (64.0 * remainder).astype('uint8')
        # Note that OpenCV by default treats image as BGR instead of RGB
        encoded_disp[:, :, 1] = d_g
        encoded_disp[:, :, 2] = d_r
        return encoded_disp

    def _save_prediction(self, disp_dir, conf_dir, disp, conf):
        """
        Save predicted disparity and confidence maps

        :param disp_dir: file path to save the disparity
        :param conf_dir: file path to save the confidence map
        :param disp: predicted raw disparity
        :param conf: confidence map
        :return: None
        """
        encoded_disp = self._disp_encoding(disp)
        conf = (255 * conf).astype('uint8')
        cv2.imwrite(disp_dir, encoded_disp)
        cv2.imwrite(conf_dir, conf)

    def _process_frame(self, l_path, r_path, disp_path, conf_path):
        """
        Process a frame by calculating the raw disparity and confidence mask

        :param l_path: path to the left image
        :param r_path: path to the right image
        :param disp_path: path to save the predicted disparity
        :param conf_path: path to save the confidence mask
        :return: None
        """
        l_im = cv2.imread(l_path, cv2.IMREAD_COLOR)
        r_im = cv2.imread(r_path, cv2.IMREAD_COLOR)
        disp, mask = self._cal_disp(l_im, r_im)
        conf = self._cal_confidence(l_im, r_im, disp, mask)
        self._save_prediction(disp_path, conf_path, disp, conf)

    def preprocess(self):
        raise NotImplementedError
